from heapq import heappop, heappush
from typing import List, Optional
from maze.environment import State


# Функция поиска с использованием стратегии равных цен
def ucs(initial_state: State) -> Optional[List[int]]:
    """
    Функция поиска решения в лабиринте с использованием алгоритма поиска по стратегии равных цен (Uniform Cost Search, UCS).

    UCS — это вариант поиска по графу, где для каждой вершины учитывается стоимость пути от начальной точки.
    В данном случае все переходы имеют одинаковую стоимость.

    Алгоритм работает следующим образом:
    1. Инициализируем приоритетную очередь, в которой каждый элемент представляет текущую стоимость, состояние и путь.
    2. Извлекаем состояние с наименьшей стоимостью из очереди.
    3. Проверяем, достигнуто ли целевое состояние — если да, возвращаем путь.
    4. Добавляем текущее состояние в множество посещённых.
    5. Генерируем возможные действия (0-3) и для каждого действия:
       - Если следующее состояние валидно и не посещено ранее, добавляем его в очередь с обновлённой стоимостью и путём.
    6. Если решение не найдено, возвращаем None.

    :param initial_state: начальное состояние лабиринта
    :return: список действий, ведущих к цели, или None, если решение не найдено
    """
    queue = [
        (0, initial_state, [])
    ]  # Очередь с приоритетом (стоимость, состояние, путь)
    visited = set()  # Множество для хранения посещённых состояний

    while queue:
        cost, current_state, path = heappop(
            queue
        )  # Извлекаем состояние с наименьшей стоимостью

        # Проверяем, достигнуто ли целевое состояние
        if current_state.finished:
            return path

        # Добавляем текущее состояние в посещённые
        visited.add(current_state)

        # Генерируем все возможные действия
        for action in range(current_state.actions):
            next_state = current_state.make_move(action)

            # Если следующее состояние валидно и не посещено ранее
            if next_state and next_state.valid and next_state not in visited:
                # Добавляем новое состояние в очередь с обновлённым путём
                heappush(queue, (cost + 1, next_state, path + [action]))

    return None  # Решение не найдено
