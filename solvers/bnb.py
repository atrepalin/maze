from typing import List, Optional
from maze.environment import State, make_move


# Функция поиска с использованием метода ветвей и границ
def bnb(initial_state: State) -> Optional[List[int]]:
    """
    Функция поиска с использованием метода ветвей и границ (Branch and Bound, BnB).

    Берётся начальное состояние и строится дерево с помощью рекурсивной функции,
    где каждый узел - это состояние, а каждый ребро - это действие,
    которое привело к этому состоянию.

    Алгоритм работает следующим образом:
    1. Инициализируем лучшее решение как None и лучшую стоимость как бесконечность.
    2. Вспомогательная рекурсивная функция explore исследует все возможные пути,
       начиная с начального состояния.
    3. Если текущая стоимость превышает лучшую найденную, прекращаем исследование.
    4. Если достигнуто целевое состояние, обновляем лучшее решение и минимальную стоимость.
    5. Если текущее состояние уже посещено, выходим из функции.
    6. Генерируем все возможные действия (0-3) и рекурсивно вызываем explore
       для следующего состояния.
    7. Удаляем текущее состояние из посещённых после его исследования.
    8. Возвращаем лучшее найденное решение.

    :param initial_state: начальное состояние
    :return: путь, который привёл к целевому состоянию, или None,
             если решение не найдено
    """
    best_solution = None  # Инициализация лучшего решения как None
    best_cost = float("inf")  # Инициализация лучшей стоимости как бесконечность
    visited = set()  # Множество для хранения посещённых состояний

    # Вспомогательная рекурсивная функция для исследования всех возможных путей
    def explore(state: State, path, cost):
        nonlocal best_solution, best_cost

        # Если текущая стоимость превышает лучшую найденную, прекращаем исследование
        if cost >= best_cost:
            return

        # Проверяем, достигнуто ли целевое состояние
        if state.finished:
            best_solution = path  # Обновляем лучшее решение
            best_cost = cost  # Обновляем минимальную стоимость
            return

        # Если текущее состояние уже посещено, выходим из функции
        if state in visited:
            return

        # Добавляем текущее состояние в посещённые
        visited.add(state)

        # Генерируем все возможные действия (0-3)
        for action in range(4):
            next_state = make_move(state, action)

            # Если следующее состояние валидно, продолжаем его исследовать
            if next_state and next_state.valid:
                # Рекурсивно вызываем explore для следующего состояния
                explore(next_state, path + [action], cost + 1)

        # Удаляем текущее состояние из посещённых после его исследования
        visited.remove(state)

    # Запускаем исследование с начального состояния
    explore(initial_state, [], 0)

    return best_solution  # Возвращаем лучшее найденное решение
