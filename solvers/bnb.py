from typing import List, Optional
from maze.environment import Situation, make_move


# Функция поиска с использованием метода ветвей и границ
def bnb(initial_situation: Situation) -> Optional[List[int]]:
    """
    Функция поиска с использованием метода ветвей и границ (Branch and Bound, BnB).

    Берётся начальное ситуация и строится дерево с помощью рекурсивной функции,
    где каждый узел - это ситуация, а каждый ребро - это действие,
    которое привело к этому состоянию.

    Алгоритм работает следующим образом:
    1. Инициализируем лучшее решение как None и лучшую стоимость как бесконечность.
    2. Вспомогательная рекурсивная функция explore исследует все возможные пути,
       начиная с начального ситуации.
    3. Если текущая стоимость превышает лучшую найденную, прекращаем исследование.
    4. Если достигнуто целевое ситуация, обновляем лучшее решение и минимальную стоимость.
    5. Если текущее ситуация уже посещено, выходим из функции.
    6. Генерируем все возможные действия (0-3) и рекурсивно вызываем explore
       для следующего ситуации.
    7. Удаляем текущее ситуация из посещённых после его исследования.
    8. Возвращаем лучшее найденное решение.

    :param initial_situation: начальное ситуация
    :return: путь, который привёл к целевому состоянию, или None,
             если решение не найдено
    """
    best_solution = None  # Инициализация лучшего решения как None
    best_cost = float("inf")  # Инициализация лучшей стоимости как бесконечность
    visited = set()  # Множество для хранения посещённых состояний

    # Вспомогательная рекурсивная функция для исследования всех возможных путей
    def explore(situation: Situation, path, cost):
        nonlocal best_solution, best_cost

        # Если текущая стоимость превышает лучшую найденную, прекращаем исследование
        if cost >= best_cost:
            return

        # Проверяем, достигнуто ли целевое ситуация
        if situation.finished:
            best_solution = path  # Обновляем лучшее решение
            best_cost = cost  # Обновляем минимальную стоимость
            return

        # Если текущее ситуация уже посещено, выходим из функции
        if situation in visited:
            return

        # Добавляем текущее ситуация в посещённые
        visited.add(situation)

        # Генерируем все возможные действия (0-3)
        for action in range(4):
            next_situation = make_move(situation, action)

            # Если следующее ситуация валидно, продолжаем его исследовать
            if next_situation and next_situation.valid:
                # Рекурсивно вызываем explore для следующего ситуации
                explore(next_situation, path + [action], cost + 1)

        # Удаляем текущее ситуация из посещённых после его исследования
        visited.remove(situation)

    # Запускаем исследование с начального ситуации
    explore(initial_situation, [], 0)

    return best_solution  # Возвращаем лучшее найденное решение
